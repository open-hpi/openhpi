<!-- ...................................................................... -->
<!-- $Id$ ........................................ -->
<!-- 
        (C) Copyright Intel Corporation. 2003
 
        Authors:
            Tariq Shureih <tariq.shureih@intel.com>

        This material may be distributed only subject to the terms and 
        conditions set forth in the Open Publication License, v1.0 or later 
        (the latest version is currently available at 
        http://www.opencontent.org/openpub/).  Distribution of substantively 
        modified version of this document is prohibited without the explicit 
        permission of the copyright holder.

        Other company, product, or service names may be trademarks or service 
        marks of others.
-->

  <chapter>
  <title>OpenHPI Plugin Development Guide</title>
  <para>
	This chapter is a developer's guide to writing an openhpi plug-in.
	The hope is that by providing this documentation in addition to
	the source code in CVS, developers will have all the tools needed
	to enable support for a given platform under openhpi.
  </para>
  <sect1>
    <title>General plug-in concepts</title>
    <para>
	As explained earlier in this manual, plug-ins are at the heart of openhpi.
	They serve as the proxy to hardware management interfaces and protocols.
	A plug-in has two main roles.
	First, to interface with the hardware management interface and gather data.
	Second, format that data into HPI data structures and send them up to the
	main openHpi library.
	
	Further, as openHpi based application need to communicate commands to the
	hardware, the infrastructure library uses the 'abi' interface functions
	to communicate with a plug-in and send commands and/or data to the hardware.
    </para>
    <para>
	Every plug-in in openhpi requires the following:
	<literal>struct oh_abi_v2</literal> declaration such as:
    </para>
    <para>
    <programlisting role="C">

static struct oh_abi_v2 my_plugin = {
	.open				= my_open,
	.close				= my_close,
	.get_event			= my_get_event,
	.discover_resources     	= my_discover_resources,
	.get_self_id			= my_get_self_id,
	.get_sel_info			= my_get_sel_info,
	.set_sel_time			= my_set_sel_time,
	.add_sel_entry			= my_add_sel_entry,
	.del_sel_entry			= my_del_sel_entry,
	.get_sel_entry			= my_get_sel_entry,
	.get_sensor_data		= my_get_sensor_data,
	.get_sensor_thresholds		= my_get_sensor_thresholds,
	.set_sensor_thresholds		= my_set_sensor_thresholds,
	.get_sensor_event_enables	= my_get_sensor_event_enables,
	.set_sensor_event_enables	= my_set_sensor_event_enables,
	.get_control_state		= my_get_control_state,
	.set_control_state		= my_set_control_state,
};
    </programlisting>
    </para>
    <para>
	This C99 style structure relates to the function pointers defined
	in <literal>plugin.h</literal> and is the entry point into plug-in functions.

	The sesond requirement is the get_interface function which is called
	when a plug-in is initialized by the infrastructure.
	It exposes the internal (above) functions a plug-in supports/implements.

	The functions looks like:
    </para>
    <para>
    <programlisting role="C">
int get_interface(void **pp, uuid_t uuid)
{
	if (uuid_compare(uuid, UUID_OH_ABI_V2)==0) {
		*pp = &<literal>oh_my_plugin</literal>;
		return 0;
	}

	*pp = NULL;
	return -1;
}
    </programlisting>
    </para>

    <sect2>
    <title>Naming convention and return codes</title>
    <para>

	You'll notice through out the code that functions, variables and structures
	start with <literal>oh_</literal>.
	This stands for OpenHpi :)
    </para>

    <para>
	Return codes:
    </para>
    <para>
	Plug-ins in OpenHpi shall return 0 for success and negative numbers for errors.
    </para>
    <note>
    <para>
	 The use of HPI defined return codes such as SA_OK and SA_ERR_HPI_ERROR
	 is allowed as well; given that it will not present a problem
	 on different architectures.
    </para>
    </note>
    </sect2>
	

    <sect2>
    <title>The <literal>Open</literal> function</title>
    <para>
	<programlisting>
prototype:
static void *my_open(GHashTable *config_file);
	</programlisting>
    </para>
	<para>
	The open function is the first function called when a plug-in is initialized.
	It takes one parameter of type GHashTable (from glib), a pointer to the hanlder's
	config hash which would have all parameters for your plug-in.
	</para>

	<para>
	In the open function you would do what your plug-in requires to initialize
	access to the hardware management protocol.
	</para>
	<para>
	Further, you would initialize the oh_handler_state elements. Allocate the 
	handler structure, parse the plug-in parameters from the confi hash, allocate
	the rptcache and initialize any private data structures in your plug-in.
    	</para>
	<para>
	When done, you would return a pointer to the handler allocated for this plugin
	instance.
	</para>
   </sect2>

    <sect2>
    <title>The <literal>close</literal> function</title>
    <para>
	<programlisting>
prototype:
static void *my_close(void *hnd);
	</programlisting>
    </para>
    <para>
	The close function is called when a plug-in is finalized.
	You would close any open connection, free any private data structures and
	terminate all loose data.
    </para>

   </sect2>

    <sect2>
    <title>The <literal>discover_resources</literal> function</title>
    <para>
	<programlisting>
prototype:
static void *discover_resources(*hnd);
	</programlisting>
    </para>
    <para>
	The discover_resources function is the function which reports the plug-in's
	findings of resources, sensors, controls, etc. to the infrastructure.
    </para>

    <para>
	In most existing plug-ins, the code would retrieve RPT entries from the rptcache
	and format then into oh_event(s) structures and append them into the eventq.
	The infrastructure would retrieve these events from each plug-in defined in the
	config file and store them in the main RPT table of the infrastructure.
    </para>

   </sect2>
</sect1>

</chapter>
